<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/SpringMVC/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/SpringMVC/" rel="alternate" type="text/html" /><updated>2017-04-12T16:32:36+08:00</updated><id>http://localhost:4000/SpringMVC/</id><title type="html">SpringMVC API入门教程</title><subtitle>技术支持：河北工业大学梦云智软件开发团队
</subtitle><entry><title type="html">第十一节：完善测试</title><link href="http://localhost:4000/SpringMVC/chapter2/delete-test/" rel="alternate" type="text/html" title="第十一节：完善测试" /><published>2017-04-12T15:12:37+08:00</published><updated>2017-04-12T15:12:37+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/delete-test</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/delete-test/">&lt;p&gt;我们在前面进行单元测试时，启动测试程序后，需要查看控制台来提到是否达到了我们的预期。这在一些基本的&lt;code class=&quot;highlighter-rouge&quot;&gt;CRUD&lt;/code&gt;操作中，还可以实现。但如果实现的逻辑过多，再使用这种办法，便会捉襟见肘了。&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;为我们提供了更加强大的测试方法。&lt;/p&gt;

&lt;p&gt;本节中，让我们共同学习使用&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;依赖来进行单元测试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;官方教程:&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;https://spring.io/guides/gs/testing-web/&quot;&gt;https://spring.io/guides/gs/testing-web/&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;断言测试&quot;&gt;断言测试&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// import static :导入的类为静态类，在本测试用例中只导入一次&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Assertions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unitDeleteTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 实例化教师 李四&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lisi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;lisi@email.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;scse of hebut&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 断言新增教程的ID为null&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 保存李四至数据库&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 断言李四的id不是null&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNotNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 断方李的ID大于0&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNotZero&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 删除关键字对应的实体&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deleteTeacherById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 数据查找，看数据是否进行了删除&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 断言查询到的实体结果为null&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如上所示，我们导入了&lt;code class=&quot;highlighter-rouge&quot;&gt;org.assertj.core.api.Assertions.assertThat&lt;/code&gt;静态类，并使用了该类的：&lt;code class=&quot;highlighter-rouge&quot;&gt;isNull()&lt;/code&gt;来断言值为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;isNotNull()&lt;/code&gt;来断言值不为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;inNotZero()&lt;/code&gt;来断言值不为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此时，当我们再次启动单元测试时。只需要观察最后的测试结果就可以了。如果测试通过，测试的结果将显示绿色，如果测试不通过，测试的结果将显示红色。此外，我还还可以启动一个测试类中的所有测试用例，最终通过观察测试结果的方法来判断这个类中的所有的测试方法是否通过。&lt;/p&gt;

&lt;p&gt;比如我们在测试类中，有5个测试方法，则可以通过对类的测试，一次性的完成5个测试用例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/35.png&quot; alt=&quot;class unit test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，如果我们随意修改一个断言值，制造一些不成的用例，那么，将得到如下的测试失败的提示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/36.png&quot; alt=&quot;class unit test failed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;控制台会提示我们共进行了5个测试，其中有一个测试失败了，这个测试是&lt;code class=&quot;highlighter-rouge&quot;&gt;unitDeleteTest&lt;/code&gt;。当我们修改代码后，我们可以点击最左侧的第二个按钮（图中红圈）来单独启动这个错误的用例。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;参考文档：&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;https://joel-costigliola.github.io/assertj/&quot;&gt;https://joel-costigliola.github.io/assertj/&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharSequenceAssert.html#containsOnlyDigits--&quot;&gt;http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharSequenceAssert.html#containsOnlyDigits–&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;实际开发&quot;&gt;实际开发&lt;/h1&gt;
&lt;p&gt;在实际的开发中，流程往往是这样的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;高级工程师根据项目经理的要求以及项目原型、需求说明，研发类图、时序图。&lt;/li&gt;
  &lt;li&gt;中级工程师会按类图与时序图进行基础代码的编写。
    &lt;ul&gt;
      &lt;li&gt;基本代码的编写过程中，我们只给出函数名，参数，返回值直接为null。&lt;/li&gt;
      &lt;li&gt;中级工程师们针对每一个方法，都去建立一个单元测试的方法，在这个方法中，写清楚单元测试的内容。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;初级工程师们按照类图，时序图，以及单元测试，进行代码的开发。
    &lt;ul&gt;
      &lt;li&gt;以是否通过单元测试，做为方法是否开发完毕的依据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，如果我们根本没有接触过单元测试，或是认为单元测试繁琐，完全没有必要的话。那么，我们的定位只能是程序员(computer programmer)，而非软件工程师（software development engineer）。
下图诠释了两者的区别:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/37.png&quot; alt=&quot;cs sde&quot; /&gt;&lt;/p&gt;

&lt;p&gt;让我们一起，在计算机工程中，不倦地追求高远，彻底脱离cs队伍，投入software development engineer的怀抱。Just do it!&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">我们在前面进行单元测试时，启动测试程序后，需要查看控制台来提到是否达到了我们的预期。这在一些基本的CRUD操作中，还可以实现。但如果实现的逻辑过多，再使用这种办法，便会捉襟见肘了。SpringMVC为我们提供了更加强大的测试方法。</summary></entry><entry><title type="html">第十节：删除数据 – delete</title><link href="http://localhost:4000/SpringMVC/chapter2/10-delete/" rel="alternate" type="text/html" title="第十节：删除数据 -- delete" /><published>2017-04-12T08:45:20+08:00</published><updated>2017-04-12T08:45:20+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/10-delete</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/10-delete/">&lt;p&gt;数据删除的时序图与更新相同，由&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;层调用&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;，然后由&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;repository&lt;/code&gt;来完成删除操作。&lt;/p&gt;

&lt;p&gt;我们参考&lt;code class=&quot;highlighter-rouge&quot;&gt;spring data jpa&lt;/code&gt;的开发文档&lt;a href=&quot;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/&quot;&gt;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/&lt;/a&gt;, 找到4.1 Core concepts。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/32.png&quot; alt=&quot;4.1 Core concepts&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，我们使用的便是其为我们提供的删除操作。&lt;/p&gt;

&lt;h2 id=&quot;在接口中建立方法&quot;&gt;在接口中建立方法&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TeacherService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;saveTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EntityNotFoundException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 删除实体&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;实现接口中的方法&quot;&gt;实现接口中的方法&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacherTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 实例化教师 李四&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lisi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;lisi@email.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;scse of hebut&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 保存李四至数据库&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 打印插入的数据&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 执行删除操作&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deleteTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 数据查找，看数据是否进行了删除&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;控制台：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 插入新数据 -- 在执行save()操作时， Hibernate 自动生成
Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
// 打印插入的数据 -- System.out.println(teacherLisi)
Teacher{id=1, name='lisi', email='lisi@email.com', address='scse of hebut', sex=false}
// 在删除前，先查询数据表中是否存在该条数据 -- 执行delelteTacher操作时, Hibernate 自动生成
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
// 删除数据 -- 执行delelteTacher操作时, Hibernate 自动生成
Hibernate: delete from teacher where id=?
// 查打数据 -- 执行findOne操作时，Hibernate 自动生成
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
// 打印查询到的数据 -- System.out.println(teacher);
null
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;对接c层&quot;&gt;对接C层&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;c1&quot;&gt;// @DeleteMapping 表明该方法只接收 delete 请求.&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@DeleteMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deleteTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;测试-1&quot;&gt;测试&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;增加数据&lt;/li&gt;
  &lt;li&gt;查询数据&lt;/li&gt;
  &lt;li&gt;删除数据&lt;/li&gt;
  &lt;li&gt;再查询数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/4.gif&quot; alt=&quot;delete action test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有人可能会有一些疑问：我们进行删除操作时，并没有返回任何值，我们怎么知道删除成功了呢？当删除失败时，又会得到什么样的提示呢？&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;中，返回的结果状态值存在于&lt;code class=&quot;highlighter-rouge&quot;&gt;header&lt;/code&gt;中。当&lt;code class=&quot;highlighter-rouge&quot;&gt;header&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;200&lt;/code&gt;时，表示操作成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/33.png&quot; alt=&quot;status 200&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;更多方法&quot;&gt;更多方法&lt;/h1&gt;
&lt;p&gt;相信在上面书写代码的过程中，我们已经发现了&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;给我们提供的不止一个删除方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/34.png&quot; alt=&quot;more delete&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们调用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete()&lt;/code&gt;时，会提示我们有3个参数可选。这说明有3个&lt;code class=&quot;highlighter-rouge&quot;&gt;delete()&lt;/code&gt;方法，分别接收了3种参数类型:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一种是&lt;code class=&quot;highlighter-rouge&quot;&gt;Long&lt;/code&gt;类型，表示要删除的实体的关键字。&lt;/li&gt;
  &lt;li&gt;第二种是&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;实体类型，表示要删除的实体。&lt;/li&gt;
  &lt;li&gt;第三种是&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;类型，表示要删除的&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;实体迭代器（单向链表，链表上的每个节点为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;实体）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;官方的&lt;a href=&quot;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&quot;&gt;说明文档&lt;/a&gt;中注释中的一句&lt;code class=&quot;highlighter-rouge&quot;&gt;// … more functionality omitted.&lt;/code&gt;也充分的说明了这个问题。&lt;/p&gt;

&lt;p&gt;在此，我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;补充&lt;code class=&quot;highlighter-rouge&quot;&gt;deleteTeacherById()&lt;/code&gt;方法。&lt;/p&gt;

&lt;h3 id=&quot;增加接口&quot;&gt;增加接口&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TeacherService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * 保存
     * @param id 关键字
     * @param teacher 教师
     * @return 保存后的教师
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;saveTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EntityNotFoundException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 删除实体&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacherById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 删除实体&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;实现接口&quot;&gt;实现接口&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacherById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;测试-2&quot;&gt;测试&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteTeacherByIdTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 实例化教师 李四&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lisi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;lisi@email.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;scse of hebut&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 保存李四至数据库&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 删除关键字对应的实体&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;teacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deleteTeacherById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 数据查找，看数据是否进行了删除&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacherLisi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;控制台：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
Teacher{id=1, name='lisi', email='lisi@email.com', address='scse of hebut', sex=false}
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
Hibernate: delete from teacher where id=?
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
null
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;自本节开始，不再提供完整代码。如果有参考完整代码的需求，请参考&lt;code class=&quot;highlighter-rouge&quot;&gt;github&lt;/code&gt;中的项目仓库中的&lt;code class=&quot;highlighter-rouge&quot;&gt;api&lt;/code&gt;文件夹。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">数据删除的时序图与更新相同，由C层调用service，然后由service调用repository来完成删除操作。</summary></entry><entry><title type="html">第九节：更新数据 – 对接C层</title><link href="http://localhost:4000/SpringMVC/chapter2/9-update-to-controller/" rel="alternate" type="text/html" title="第九节：更新数据 -- 对接C层" /><published>2017-04-07T15:25:59+08:00</published><updated>2017-04-07T15:25:59+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/9-update-to-controller</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/9-update-to-controller/">&lt;p&gt;以数据更新为例，在&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;的世界里，大体的操作是这样的：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/29.png&quot; alt=&quot;springmvc seq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;为我们自动实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;接口，我们手动的实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherService&lt;/code&gt;接口，并进行单元测试。在以上两个接口可用并测试的基础上，我们的C层所要做的工作就是，直接将数据转发给&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;c1&quot;&gt;// @PutMapping 表明该方法只接收 put 请求.&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@PutMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;updateTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@RequestBody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EntityNotFoundException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 数据转发&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;saveTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherService&lt;/code&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;saveTeacher&lt;/code&gt;时，可能会抛出一个异常。我们在这里，可以手动的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;try catch&lt;/code&gt;来进行处理后，重新定制一个新的异常，返回给&lt;code class=&quot;highlighter-rouge&quot;&gt;spring&lt;/code&gt;，也可以在函数声明中，加入&lt;code class=&quot;highlighter-rouge&quot;&gt;throws EntityNotFoundException&lt;/code&gt;来直接抛出这个异常。在这里，我们直接将异常向上抛出。&lt;/p&gt;

&lt;p&gt;完整代码：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mengyunzhi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.mengyunzhi.repository.Teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.mengyunzhi.repository.TeacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.mengyunzhi.service.TeacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.beans.factory.annotation.Autowired&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.bind.annotation.*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.persistence.EntityNotFoundException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.validation.Valid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * Created by panjie on 17/4/6.
 */&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 声明为Rest控制器（支持前后台分离）&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/teacher&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TeacherController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TeacherRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TeacherService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 设置路由&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@PostMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/save&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;saveTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Valid&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@RequestBody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 打印加载的数据&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 调用保存操作&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// @GetMapping 表明该方法只接收 get 请求.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// {id}即为url中传入教师关键字&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GetMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// @PathVariable 获取路由中的id值&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getTeacherById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// @PutMapping 表明该方法只接收 put 请求.&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@PutMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;updateTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@RequestBody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EntityNotFoundException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 数据转发&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacherService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;saveTeacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;正确用例，略。
错误用例：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/30.png&quot; alt=&quot;update error unit test&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;作业&quot;&gt;作业&lt;/h2&gt;
&lt;p&gt;将数据增加与删除，由直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;repository&lt;/code&gt;改写为调用&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">以数据更新为例，在SpringMVC的世界里，大体的操作是这样的：</summary></entry><entry><title type="html">第八节：更新数据 – service</title><link href="http://localhost:4000/SpringMVC/chapter2/8-update-service/" rel="alternate" type="text/html" title="第八节：更新数据 -- service" /><published>2017-04-07T15:20:42+08:00</published><updated>2017-04-07T15:20:42+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/8-update-service</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/8-update-service/">&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;层更多在功能是：数据转发，数据验证，数据绑定，路由设定等。而不负责具体的数据的处理。显然的，我们上述代码的C层中，对数据进行逻辑处理。这违背了上述的原则。&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;层负责对进行逻辑运算及数据的处理。&lt;/p&gt;

&lt;p&gt;我们在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherRepository&lt;/code&gt;时，已经体验了&lt;code class=&quot;highlighter-rouge&quot;&gt;spring&lt;/code&gt;面向接口编程的魅力。和前面一样，在建立&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;时，同样也是面向接口的。我们在其实类中引用的，也是接口，而非对象。&lt;/p&gt;

&lt;h2 id=&quot;建立接口&quot;&gt;建立接口&lt;/h2&gt;
&lt;p&gt;建立文件&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

/**
 * Created by panjie on 17/4/7.
 */
public interface TeacherService {
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;建立方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

import com.mengyunzhi.repository.Teacher;

/**
 * Created by panjie on 17/4/7.
 */
public interface TeacherService {
    /**
     * 保存
     * @param id 关键字
     * @param teacher 教师
     * @return 保存后的教师
     */
    Teacher saveTeacher(Long id, Teacher teacher);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;声明抛出异常类型&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
import javax.persistence.EntityNotFoundException;
    ...
    Teacher saveTeacher(Long id, Teacher teacher) throws EntityNotFoundException;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;实现接口&quot;&gt;实现接口&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/2.gif&quot; alt=&quot;imp interface&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没错，有了&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;一切操作就是如此的简单。如果再结合快捷键的话，相信还将是另一番天地。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;加入&lt;code class=&quot;highlighter-rouge&quot;&gt;Service&lt;/code&gt;注解&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Service            // 说明本类是一个Service，Spring在进行自动注入的时候，会将有此类注入到相应的TeacherService中。
public class TeacherServiceImpl implements TeacherService {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;自动注入&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Autowired
    private TeacherRepository teacherRepository;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;实现数据更新&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Override
    public Teacher saveTeacher(Long id, Teacher teacher) throws EntityNotFoundException {
        // 判断是否存在该实体，如果不存在，则报错
        if (teacherRepository.findOne(id) == null) {
            throw new EntityNotFoundException(&quot;传入的ID值：&quot; + id.toString() + &quot;有误。未找到对应的实体&quot;);
        }

        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;文件夹中，新建对应的测试类，进行单元测试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/26.png&quot; alt=&quot;new unit test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;增加单元测试注解&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherServiceImplTest {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;编写测试方法:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
       
        // 保存李四至数据库
        
        // 打印李四的数据

        // 实例化教师 张三
       
        // 将张三的数据更新到原李四的数据中

        // 查询并打印更新后的数据
        
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
        Teacher teacherLisi = new Teacher(&quot;lisi&quot;,
                &quot;lisi@email.com&quot;,
                &quot;scse of hebut&quot;,
                false);

        // 保存李四至数据库
        teacherLisi = teacherRepository.save(teacherLisi);

        // 打印李四的数据
        System.out.println(teacherLisi);

        // 实例化教师 张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 将张三的数据更新到原李四的数据中
        Teacher newTeacher = teacherService.saveTeacher(teacherLisi.getId(), teacherZhangsan);

        // 查询并打印更新后的数据
        System.out.println(newTeacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;在代码实现中，我们使用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherRepository&lt;/code&gt;及&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherService&lt;/code&gt;, 这两个对象也是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;来由&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;完成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * Created by panjie on 17/4/7.
 */
@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherServiceImplTest {
    @Autowired
    private TeacherService teacherService;
    @Autowired
    private TeacherRepository teacherRepository;

    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
        Teacher teacherLisi = new Teacher(&quot;lisi&quot;,
                &quot;lisi@email.com&quot;,
                &quot;scse of hebut&quot;,
                false);

        // 保存李四至数据库
        teacherLisi = teacherRepository.save(teacherLisi);

        // 打印李四的数据
        System.out.println(teacherLisi);

        // 实例化教师 张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 将张三的数据更新到原李四的数据中
        Teacher newTeacher = teacherService.saveTeacher(teacherLisi.getId(), teacherZhangsan);

        // 查询并打印更新后的数据
        System.out.println(newTeacher);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们点击方法前面的绿色启动按钮，来启动单元测试，最终将在控制台得到如下信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
Teacher{id=1, name='lisi', email='lisi@email.com', address='scse of hebut', sex=false}
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
Hibernate: update teacher set address=?, email=?, name=?, sex=? where id=?
Teacher{id=1, name='zhangsan', email='zhangsan@yunzhiclub.com', address='scse of hebut', sex=true}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中，有&lt;code class=&quot;highlighter-rouge&quot;&gt;Hibernate: &lt;/code&gt;前缀的，为&lt;code class=&quot;highlighter-rouge&quot;&gt;Hibernate&lt;/code&gt;生成的数据库操作语句。
通过观察，我们不难发现，先后进行数据的插入、更新操作。&lt;/p&gt;

&lt;h2 id=&quot;完善测试&quot;&gt;完善测试&lt;/h2&gt;
&lt;p&gt;有了正确的用例，我们也需要错误的用例。
新建方法，并加入注释：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
     * 更新的数据不存在于数据表中时，发生错误，并抛出异常
     */
    @Test
    public void saveTeacherErrorTest() {
        // 指定id为0

        // 实例化教师张三

        // 使用张三的数据来更新0号教师的数据
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
     * 更新的数据不存在于数据表中时，发生错误，并抛出异常
     */
    @Test
    public void saveTeacherErrorTest() {
        // 指定id为0
        Long id = 0L;

        // 实例化教师张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 使用张三的数据来更新0号教师的数据
        teacherService.saveTeacher(id, teacherZhangsan);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试用例：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/27.png&quot; alt=&quot;update error unit test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然这样达到了我们测试的目的，但从单元测试的规范上讲，红色代表测试发生异常，绿色才是我们想看到的。为此，我们为&lt;code class=&quot;highlighter-rouge&quot;&gt;@Test&lt;/code&gt;指定一个参数，进而表明，此测试方法的期待结果是获取一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EntityNotFoundException&lt;/code&gt;类型的异常。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test(expected = EntityNotFoundException.class)
    public void saveTeacherErrorTest() {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;此时，当我们再次进行测试时，发现控制台没有报告异常，而且测试结果显示为绿色，表示测试通过。
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/28.png&quot; alt=&quot;update error unit test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import javax.persistence.EntityNotFoundException;

/**
 * Created by panjie on 17/4/7.
 */
@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherServiceImplTest {
    @Autowired
    private TeacherService teacherService;
    @Autowired
    private TeacherRepository teacherRepository;

    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
        Teacher teacherLisi = new Teacher(&quot;lisi&quot;,
                &quot;lisi@email.com&quot;,
                &quot;scse of hebut&quot;,
                false);

        // 保存李四至数据库
        teacherLisi = teacherRepository.save(teacherLisi);

        // 打印李四的数据
        System.out.println(teacherLisi);

        // 实例化教师 张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 将张三的数据更新到原李四的数据中
        Teacher newTeacher = teacherService.saveTeacher(teacherLisi.getId(), teacherZhangsan);

        // 查询并打印更新后的数据
        System.out.println(newTeacher);
    }

    /**
     * 更新的数据不存在于数据表中时，发生错误，并抛出异常
     */
    @Test(expected = EntityNotFoundException.class)     // 此方法的预期结果是获取到一个EntityNotFoundException异常
    public void saveTeacherErrorTest() {
        // 指定id为0
        Long id = 0L;

        // 实例化教师张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 使用张三的数据来更新0号教师的数据
        teacherService.saveTeacher(id, teacherZhangsan);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;单元测试参考文档：&lt;a href=&quot;http://wiki.jikexueyuan.com/project/junit/exceptions-test.html&quot;&gt;http://wiki.jikexueyuan.com/project/junit/exceptions-test.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">在SpringMVC中，C层更多在功能是：数据转发，数据验证，数据绑定，路由设定等。而不负责具体的数据的处理。显然的，我们上述代码的C层中，对数据进行逻辑处理。这违背了上述的原则。SpringMVC中，service层负责对进行逻辑运算及数据的处理。</summary></entry><entry><title type="html">第七节：更新数据 – update</title><link href="http://localhost:4000/SpringMVC/chapter2/7-update/" rel="alternate" type="text/html" title="第七节：更新数据 -- update" /><published>2017-04-07T08:50:55+08:00</published><updated>2017-04-07T08:50:55+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/7-update</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/7-update/">&lt;p&gt;和其它框架一样，在数据更新中，&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;调用的方法同&lt;code class=&quot;highlighter-rouge&quot;&gt;Create&lt;/code&gt;，即均为&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;方法。则按照前面章节的思想，我们不难写出如下数据更新的代码。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) {
        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里，我们使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;方法，其实和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;一样，这仅仅是一个请求的方法而已。除了&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;方法外，我们还会接触到&lt;code class=&quot;highlighter-rouge&quot;&gt;patch&lt;/code&gt;及&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;方法。
我们简单做个汇总：&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;方法名&lt;/th&gt;
        &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;get&lt;/td&gt;
        &lt;td&gt;用于数据的查询操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;post&lt;/td&gt;
        &lt;td&gt;用于数据的新增操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;put&lt;/td&gt;
        &lt;td&gt;用于数据的更新操作（更新实体的全部字段）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;patch&lt;/td&gt;
        &lt;td&gt;用于数据的更新操作（更新实体的部分字段）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;delete&lt;/td&gt;
        &lt;td&gt;用于数据的删除操作&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;操作相同，我们在进行数据的更新前，需要先新增一个实体。然后再对这个实体进行修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/1.gif&quot; alt=&quot;update&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;完善代码&quot;&gt;完善代码&lt;/h1&gt;
&lt;p&gt;我们看到，我们新增了一个教师，然后进行查询得到了这个教师的数据，再进行修改，然后再查询，发现教师的数据的确被我们修改了。&lt;/p&gt;

&lt;p&gt;不过，如果我们测试充分的话，也会很容易的发现：在数据修改的过程中，如果并不存在我们要修改的数据，那么则会自动的新增一条记录。而这，并不是我们想看到的。我们想要的结果是，如果有这条记录，则更新，如果没有，则提示我们不存在该条记录。&lt;/p&gt;

&lt;p&gt;完善代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) throws EntityNotFoundException {
        // 判断是否存在该实体，如果不存在，则报错
        if (teacherRepository.findOne(id) == null) {
            throw new EntityNotFoundException(&quot;传入的ID值：&quot; + id.toString() + &quot;有误。未找到对应的实体&quot;);
        }

        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;增加了传入&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;是否对应实体的判断, 如果没有找到，则抛出一个&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.persistence.EntityNotFoundException&lt;/code&gt;异常。同时，。&lt;/li&gt;
  &lt;li&gt;在函数定义时，增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;throws EntityNotFoundException&lt;/code&gt;来声明抛出的异常类型。该异常能够被&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;捕获，并且转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;格式的报错信息进行输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们输入一个并不存在实体&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;并进行测试，将得到如下提示信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/25.png&quot; alt=&quot;entity not found exception&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除此以外，根据具体的实际情况，我们还可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;为我们准备好的其它异常类型，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;BindException&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;ConversionNotSupportedException&lt;/code&gt;等等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#mvc-ann-rest-spring-mvc-exceptions&quot;&gt;https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#mvc-ann-rest-spring-mvc-exceptions&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import com.mengyunzhi.service.TeacherService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.persistence.EntityNotFoundException;
import javax.validation.Valid;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
@RequestMapping(&quot;/teacher&quot;)
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    @Autowired
    private TeacherService teacherService;

    // 设置路由
    @PostMapping(&quot;/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }

    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {
        return teacherRepository.findOne(id);
    }

    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) throws EntityNotFoundException {
        // 判断是否存在该实体，如果不存在，则报错
        if (teacherRepository.findOne(id) == null) {
            throw new EntityNotFoundException(&quot;传入的ID值：&quot; + id.toString() + &quot;有误。未找到对应的实体&quot;);
        }

        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>潘杰</name></author><summary type="html">和其它框架一样，在数据更新中，SpringMVC调用的方法同Create，即均为save()方法。则按照前面章节的思想，我们不难写出如下数据更新的代码。 // @PutMapping 表明该方法只接收 put 请求. @PutMapping(&quot;/{id}&quot;) public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) { // 对实体ID赋值, 并执行更新操作 teacher.setId(id); return teacherRepository.save(teacher); }</summary></entry><entry><title type="html">第六节：读取数据 – read</title><link href="http://localhost:4000/SpringMVC/chapter2/6-read/" rel="alternate" type="text/html" title="第六节：读取数据 -- read" /><published>2017-04-06T13:34:07+08:00</published><updated>2017-04-06T13:34:07+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/6-read</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/6-read/">&lt;p&gt;在上节中，我们给出了参考的官方文档，并且新建了接口。本节中，仍然使用上节中给出参考文档中提及到的方法，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;来实现数据的读取。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;[说明]&lt;/strong&gt;  由于在上节中，新建&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;时，已经进行过测试操作，本节再次使用该接口时，则可以直接跳过单元测试的内容。在实际的开发中也是这样的，如果该类是由你创建的，你需要对自己创建的类负责，必须进行相关的测试操作也保证类的可靠性。而如果类不是我们自己创建的，则假设该类经过了单元测试，并且可以直接被我们调用。&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;c层对接&quot;&gt;C层对接&lt;/h1&gt;
&lt;p&gt;在进行正式的对接前，我们首先要制定相关的API规范，即接收的数据都有什么，又期待返回什么样的数据。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接收教师ID&lt;/li&gt;
  &lt;li&gt;返回该ID对应的教师实体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面，我们按上述的说明，对&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherController&lt;/code&gt;类进行如下补充:&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;新建方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public Teacher getTeacherById() {
        
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;添加路由&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    public Teacher getTeacherById() {

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;添加接收参数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;获取教师实体并返回&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {  
        return teacherRepository.findOne(id);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;启动项目及MySQL数据库服务，并启动postMan对上述方法进行测试.&lt;/p&gt;

&lt;h3 id=&quot;添加一条数据&quot;&gt;添加一条数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/21.png&quot; alt=&quot;add data&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;查询刚刚添加的数据&quot;&gt;查询刚刚添加的数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/22.png&quot; alt=&quot;find data&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;查询不存在的数据&quot;&gt;查询不存在的数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/22.png&quot; alt=&quot;find not exist data&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完事代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }

    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {
        return teacherRepository.findOne(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;重构&quot;&gt;重构&lt;/h1&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherController&lt;/code&gt;中，我们定义了两处路由，都有&lt;code class=&quot;highlighter-rouge&quot;&gt;/teacher&lt;/code&gt;字符串，下面，我们通过对类添加路由的方式来进行重构，以降低代码的冗余。同时，更加明确的指定请求方式。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
@RestController
@RequestMapping(&quot;/teacher&quot;)
public class TeacherController {
    ...
    @PostMapping(&quot;/save&quot;)
    ...
    @GetMapping(&quot;/{id}&quot;)
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
@RequestMapping(&quot;/teacher&quot;)
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    // 设置路由
    @PostMapping(&quot;/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }

    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {
        return teacherRepository.findOne(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&quot;&gt;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;如果你感觉很轻松的就学习完了本节内容，那么说明你的基础打的比较牢固，具有很好的学习精神，具备了一定的英文阅读能力。恭喜你，在计算机工程的道路上，你将越走越加平坦。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">在上节中，我们给出了参考的官方文档，并且新建了接口。本节中，仍然使用上节中给出参考文档中提及到的方法，使用TeacherRepository来实现数据的读取。</summary></entry><entry><title type="html">第五节：数据验证</title><link href="http://localhost:4000/SpringMVC/chapter2/5-validate/" rel="alternate" type="text/html" title="第五节：数据验证" /><published>2017-04-06T13:33:17+08:00</published><updated>2017-04-06T13:33:17+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/5-validate</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/5-validate/">&lt;p&gt;有数据输入，就必然涉及到数据的验证以及数据验证失败后的处理。本节中，让我们共同学习&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;是如何进行数据验证的。&lt;/p&gt;

&lt;p&gt;通过上节的学习，我们得知，&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@RequestBody&lt;/code&gt;注解将请求数据绑定到相应的实体中(对象)。数据绑定，其实是利用实体的&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法进行了赋值的过程。数据的验证的过程我们也放置于此。&lt;/p&gt;

&lt;p&gt;我们找到&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;实体，使用注解的方法设置如下验证规则:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Column(length = 25)            // 声明字段的长度为25
    @Size(min = 2, max = 25)        // 最小长度为2（不能为空），最大长度为25
    private String name = &quot;&quot;;       // 姓名

    @Column(length = 50)
    @NotNull                        // 此列不能为空
    @Email                          // 邮箱验证
    @Size(max = 50)                 // 最大长度为50
    private String email = &quot;&quot;;      // 邮箱

    @Size(max = 255)                // 最大长度为255
    private String address = &quot;&quot;;    // 地址. 不进行@Column声明，则默认长度为255

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;


import org.hibernate.validator.constraints.Email;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(length = 25)            // 声明字段的长度为25
    @Size(min = 2, max = 25)        // 最小长度为2（不能为空），最大长度为25
    private String name = &quot;&quot;;       // 姓名

    @Column(length = 50)
    @NotNull                        // 此列不能为空
    @Email                          // 邮箱验证
    @Size(max = 50)                 // 最大长度为50
    private String email = &quot;&quot;;      // 邮箱

    @Size(max = 255)                // 最大长度为255
    private String address = &quot;&quot;;    // 地址. 不进行@Column声明，则默认长度为255

    private Boolean sex = false;    // 性别：false(0)，男。true(1)，女.

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setSex(Boolean sex) {
        this.sex = sex;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getAddress() {
        return address;
    }

    public Boolean getSex() {
        return sex;
    }

    public Teacher(String name, String email, String address, Boolean sex) {
        this.name = name;
        this.email = email;
        this.address = address;
        this.sex = sex;
    }

    public Teacher() {
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, email='&quot; + email + '\'' +
                &quot;, address='&quot; + address + '\'' +
                &quot;, sex=&quot; + sex +
                '}';
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;重新启动应用:&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;正常数据:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/17.png&quot; alt=&quot;validate&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;姓名过短:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/18.png&quot; alt=&quot;validate name&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;邮箱格式不合法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/19.png&quot; alt=&quot;validate email&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其它的自行验证一下吧。&lt;/p&gt;

&lt;h2 id=&quot;格式化验证错误信息&quot;&gt;格式化验证错误信息&lt;/h2&gt;
&lt;p&gt;前面，我们虽然得到了错误的验证信息，但是错误的信息全部在&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;字段中，这无疑为我们前台排错增加了一定的难度。&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;当然想到了这点。
我们打开&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherController&lt;/code&gt;控制器，为&lt;code class=&quot;highlighter-rouge&quot;&gt;saveTeacher&lt;/code&gt;方法增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;@Valid&lt;/code&gt;注解，并重新启动应用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该注解位于：javax.validation.Valid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时，当我们再次发送一些数据而未验证成功时，将得到如下的错误信息:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/20.png&quot; alt=&quot;validate format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没错，这就是我们想要的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：
&lt;a href=&quot;https://spring.io/guides/gs/validating-form-input/&quot;&gt;https://spring.io/guides/gs/validating-form-input/&lt;/a&gt;
&lt;a href=&quot;http://hibernate.org/validator/&quot;&gt;http://hibernate.org/validator/&lt;/a&gt; &lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/&quot;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/&lt;/a&gt; &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html&quot;&gt;https://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">有数据输入，就必然涉及到数据的验证以及数据验证失败后的处理。本节中，让我们共同学习SpringMVC是如何进行数据验证的。</summary></entry><entry><title type="html">第四节：增加数据 – create</title><link href="http://localhost:4000/SpringMVC/chapter2/4-create/" rel="alternate" type="text/html" title="第四节：增加数据 -- create" /><published>2017-04-06T08:08:09+08:00</published><updated>2017-04-06T08:08:09+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/4-create</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/4-create/">&lt;p&gt;和我们以前学习的框架基本一致，框架已经为我们封装好了大部分的基本操作，我们只需要做适当的继承操作就可以实现大部的数据操作了。&lt;/p&gt;

&lt;h1 id=&quot;crudrepository&quot;&gt;CrudRepository&lt;/h1&gt;
&lt;p&gt;在SpringMVC中，为我提供了用于进行数据增查删改删的&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;接口。下面，我们来新建第一个用于数据表操作的接口文件 – &lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;没错，是&lt;code class=&quot;highlighter-rouge&quot;&gt;接口&lt;/code&gt;，而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;类&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;做自动的为我们的接口做相关的实现。而我们并不需要关心&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;是怎么做到的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/9.png&quot; alt=&quot;TeacherRepository&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import org.springframework.data.repository.CrudRepository;

/**
 * Created by panjie on 17/4/6.
 */
public interface TeacherRepository extends CrudRepository&amp;lt;Teacher, Long&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;文件夹中的同名位置上新建对应的测试类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/10.png&quot; alt=&quot;TeacherRepositoryTest&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * Created by panjie on 17/4/6.
 */
// 使用以下两个注解来说明：本测试类基于SpringBoot。(必须)
@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherRepositoryTest {
    // @Autowired注解：自动加载Spring为我们自动实例化的实现了TeacherRepository接口的对象
    @Autowired
    private TeacherRepository teacherRepository;

    // @Test：本方法为一个单元测试方法
    @Test
    public void addTeacher() {
        // 执行数据保存操作
        teacherRepository.save(new Teacher());

        // 打印Spring为我们自动实例化的对象
        System.out.println(teacherRepository);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后我们点击方法前面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Run Test&lt;/code&gt;小图标&lt;img src=&quot;/SpringMVC/assets/image/chapter2/11.png&quot; alt=&quot;run test&quot; /&gt;
来启动单元测试。&lt;/p&gt;

&lt;p&gt;我们将在控制台，得到如下信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;org.springframework.data.jpa.repository.support.SimpleJpaRepository@340cb97f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;没错，这就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;自动实例化的&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherRepository&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时，我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Navicat&lt;/code&gt;，打开数据表，发现里面已经成功的增加了一条数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/12.png&quot; alt=&quot;add data&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在实际的开发过程中，每新增一条数据，都去数据表中进行查看，效率还是比较低的。我们还可以通过修改配置文件的方法，来直接输出&lt;code class=&quot;highlighter-rouge&quot;&gt;sql&lt;/code&gt;语句，来查看是否执行了我们想要的操作。&lt;/p&gt;

&lt;p&gt;在配置文件中，增加一行:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 显示SQL语句
spring.jpa.show-sql=true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;增加后，整体配置文件如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在项目初始化时，重新创建数据表
spring.jpa.hibernate.ddl-auto=create
# 指定连接的类型为mysql 连接的地址为：localhost 端口为3306 ，数据为springmvc
spring.datasource.url=jdbc:mysql://localhost:3306/springmvc
# 用户名为root
spring.datasource.username=root
# 密码为空
spring.datasource.password=
# 显示SQL语句
spring.jpa.show-sql=true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时，当我们再次&lt;code class=&quot;highlighter-rouge&quot;&gt;Run Test&lt;/code&gt;的时候，在控制台中，将得到如下信息:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当我们看到这条语句时，就可以放心的认为：数据文件已经成功的插入到数据表中了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&quot;&gt;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;对接c层&quot;&gt;对接C层&lt;/h1&gt;
&lt;p&gt;有了上面的测试代码，C层对接起来，也相应的容易的多了。但对接以前，我们需要做了解以下几点。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据发送请求的方式为&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;数据以&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;的格式进行发送。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;数据中，发送新增教师的姓名、地址、邮箱、性别信息。&lt;/li&gt;
  &lt;li&gt;除性别的变量类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;外，其它的全部为&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了以上几点，那我们如下定义后台。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接收&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;数据&lt;/li&gt;
  &lt;li&gt;按收&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;格式传入的数据&lt;/li&gt;
  &lt;li&gt;接收数据后，进行数据表的存储操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;新建控制器&quot;&gt;新建控制器&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/13.png&quot; alt=&quot;new controller&quot; /&gt;&lt;/p&gt;

&lt;p&gt;自动装入&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
@RestController
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加方法，并设置路由:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    public Teacher saveTeacher() {
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取请求数据，并装入&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@RequestBody Teacher teacher) {
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印获取的数据，并执行保存操作:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    public Teacher saveTeacher(@RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;测试-1&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;重新启动应用, 我们可以点击&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMvcApplication&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数左侧的启动按钮，也可以点击右上角的启动按钮。如果你点击的为右上角按钮，那么需要注意进行切换（这是由于我们刚刚建立过测试类，而测试类也是可以直接启动的）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/14.png&quot; alt=&quot;run&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动&lt;code class=&quot;highlighter-rouge&quot;&gt;postMan&lt;/code&gt;, 并发送请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/15.png&quot; alt=&quot;post man&quot; /&gt;&lt;/p&gt;

&lt;p&gt;请求结果：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/16.png&quot; alt=&quot;post man&quot; /&gt;&lt;/p&gt;

&lt;p&gt;控制台信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Teacher{id=null, name='zhangsan', email='zhangsan@yunzhiclub.com', address='scse of hebut', sex=false}
Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时，我们看到了&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;sql&lt;/code&gt;语句，至此，基本确认数据已经被成功增加到数据库了，如果你还不放心，可以打开&lt;code class=&quot;highlighter-rouge&quot;&gt;navicat&lt;/code&gt;来查看并确认一下。&lt;/p&gt;

&lt;p&gt;我们在前面，按照&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;构造函数中，变量的顺序使用&lt;code class=&quot;highlighter-rouge&quot;&gt;postman&lt;/code&gt;将变量按顺序一一进行了传入。那么是否可以改变变量传入的顺序呢？比如说，我们将请求的&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;数据变更为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;scse of hebut&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LISI&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;zhangsan@yunzhiclub.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;尝试并总结一下它的规律吧。&lt;/p&gt;

&lt;h1 id=&quot;pagingandsortingrepository&quot;&gt;PagingAndSortingRepository&lt;/h1&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;以下内容后期将迁入至其它章节，本节请直接略过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;只能实现基本的增查改删，大多数的时候，我们还需要对数据进行分页、排序。强大的&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;当然想到了这点– &lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在官方文档中，我们看到是这样介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;的:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface PagingAndSortingRepository&amp;lt;T, ID extends Serializable&amp;gt;
  extends CrudRepository&amp;lt;T, ID&amp;gt; {

  Iterable&amp;lt;T&amp;gt; findAll(Sort sort);

  Page&amp;lt;T&amp;gt; findAll(Pageable pageable);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是的，正如我们看到的一样：&lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;继承了&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;，因而&lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;具有&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;的全部功能，并且在此之上，补充了两个用于排序和分页的功能。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">和我们以前学习的框架基本一致，框架已经为我们封装好了大部分的基本操作，我们只需要做适当的继承操作就可以实现大部的数据操作了。</summary></entry><entry><title type="html">第三节：创建数据表</title><link href="http://localhost:4000/SpringMVC/chapter2/create-tabel/" rel="alternate" type="text/html" title="第三节：创建数据表" /><published>2017-04-05T15:22:52+08:00</published><updated>2017-04-05T15:22:52+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/create-tabel</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/create-tabel/">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;中集成了&lt;code class=&quot;highlighter-rouge&quot;&gt;hibernate&lt;/code&gt;框架，所以在&lt;code class=&quot;highlighter-rouge&quot;&gt;SrpingMVC&lt;/code&gt;,有关关系型数据库的部分，我们完全可以参考&lt;code class=&quot;highlighter-rouge&quot;&gt;hibernate&lt;/code&gt;的开发文档。&lt;code class=&quot;highlighter-rouge&quot;&gt;hibernate&lt;/code&gt;为我们提供了这样一个功能：将带有相关注解的&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;类自动与&lt;code class=&quot;highlighter-rouge&quot;&gt;数据表&lt;/code&gt;进行关系。从而使我们可以完全的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;代码来定义数据表。这样的做的优点当然很多，对于我们而言，我们再也不需要为了数据表不统一造成的各种莫名&lt;code class=&quot;highlighter-rouge&quot;&gt;BUG&lt;/code&gt;而烦恼了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JPA&lt;/code&gt;全称&lt;code class=&quot;highlighter-rouge&quot;&gt;Java Persistence API&lt;/code&gt;.&lt;code class=&quot;highlighter-rouge&quot;&gt;JPA&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK 5.0&lt;/code&gt;注解或&lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。&lt;a href=&quot;http://baike.baidu.com/item/JPA&quot;&gt;http://baike.baidu.com/item/JPA&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;新建实体类&quot;&gt;新建实体类&lt;/h1&gt;
&lt;p&gt;我们新建&lt;code class=&quot;highlighter-rouge&quot;&gt;repository&lt;/code&gt;包，并在该包中，新建&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;类。
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/3.png&quot; alt=&quot;new table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@Entity&lt;/code&gt;来说明该类对应一个数据表,数据表的名字与类名相同。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@Id&lt;/code&gt;来说明：此字段是该表的主键。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@GeneratedValue(strategy = GenerationType.AUTO)&lt;/code&gt;来说明：该主键的生成策略为自动，对应MySQL的属性为’Auto increment’&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;只所以要将上述3个注解单独拿出来，是因为以为我们要常与它们打交道。每新建一个实体，上述的操作都是必须的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;我们再次点击&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Run&lt;/code&gt;按钮，来重新启动项目。项目成功启动后，我们将得到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;表，这个表中，有一个字段&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;，该字段为表的主键，该字段被设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Auto increment&lt;/code&gt;属性。如下：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/4.png&quot; alt=&quot;edit table&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;增加其它属性&quot;&gt;增加其它属性&lt;/h1&gt;
&lt;p&gt;参考&lt;code class=&quot;highlighter-rouge&quot;&gt;ER&lt;/code&gt;图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/6.png&quot; alt=&quot;Logical model&quot; /&gt; 
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/7.png&quot; alt=&quot;physical model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;定制JAVA代码:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import javax.persistence.*;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @Column(length = 25)    // 声明字段的长度为25
    private String name;    // 姓名
    @Column(length = 50)
    private String email;   // 邮箱
    private String address; // 地址. 不进行@Column声明，则默认长度为255
    private Boolean sex;    // 性别：0，男。1，女.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后我们重新启动项目，将得到拥有如下类型的数据表:
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/5.png&quot; alt=&quot;edit table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，按照&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;的规范，我们增加&lt;code class=&quot;highlighter-rouge&quot;&gt;set\get&lt;/code&gt;函数，构造函数及&lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;函数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;来快速生成上面所提到的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最终完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import javax.persistence.*;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @Column(length = 25)            // 声明字段的长度为25
    private String name = &quot;&quot;;       // 姓名
    @Column(length = 50)
    private String email = &quot;&quot;;      // 邮箱
    private String address = &quot;&quot;;    // 地址. 不进行@Column声明，则默认长度为255
    private Boolean sex = false;    // 性别：false(0)，男。true(1)，女.

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setSex(Boolean sex) {
        this.sex = sex;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getAddress() {
        return address;
    }

    public Boolean getSex() {
        return sex;
    }

    public Teacher(String name, String email, String address, Boolean sex) {
        this.name = name;
        this.email = email;
        this.address = address;
        this.sex = sex;
    }

    public Teacher() {
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, email='&quot; + email + '\'' +
                &quot;, address='&quot; + address + '\'' +
                &quot;, sex=&quot; + sex +
                '}';
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后，我们重新运行项目，以确保未发生拼写错误。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#basic-provided&quot;&gt;官方文档：java 与 数据表类型对照&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">SpringMVC中集成了hibernate框架，所以在SrpingMVC,有关关系型数据库的部分，我们完全可以参考hibernate的开发文档。hibernate为我们提供了这样一个功能：将带有相关注解的java类自动与数据表进行关系。从而使我们可以完全的使用java代码来定义数据表。这样的做的优点当然很多，对于我们而言，我们再也不需要为了数据表不统一造成的各种莫名BUG而烦恼了。</summary></entry><entry><title type="html">第二节：添加jpa、mysql模块</title><link href="http://localhost:4000/SpringMVC/chapter2/add-jpa-and-mysql/" rel="alternate" type="text/html" title="第二节：添加jpa、mysql模块" /><published>2017-04-05T14:47:23+08:00</published><updated>2017-04-05T14:47:23+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/add-jpa-and-mysql</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/add-jpa-and-mysql/">&lt;p&gt;如果在项目刚刚生成时，你查看过生成项目的目录信息，不难发现我们在前面选择过一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;的Spring核心模块，被写入了根目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;即如下代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;的核心模块。本章中，我们将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;做为后台的数据库。此时，我们需要加入&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;模块来说明:本项目是需要关系型数据库来支撑的；我们需要加入&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;模块，来说明：本项目使用的关系型数据库的类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在本教程中，我们仍然使用XAMPP中集成的&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们首先启动&lt;code class=&quot;highlighter-rouge&quot;&gt;xampp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;服务，并使用&lt;code class=&quot;highlighter-rouge&quot;&gt;navicat&lt;/code&gt;来建立本项目要使用的数据库: &lt;code class=&quot;highlighter-rouge&quot;&gt;springmvc&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/1.png&quot; alt=&quot;new database springmvc&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;加入jpa模块&quot;&gt;加入JPA模块&lt;/h1&gt;
&lt;p&gt;我们打开&lt;code class=&quot;highlighter-rouge&quot;&gt;/pom.xml&lt;/code&gt;文件的如下代码段:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;增加&lt;code class=&quot;highlighter-rouge&quot;&gt;JPA&lt;/code&gt;模块后：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重新导入依赖模块:
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/2.png&quot; alt=&quot;new database springmvc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在导入过程中,&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;最下侧将有导入进度的提示。未报错，则导入成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[注意]&lt;/strong&gt; 当&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;第一次变化时，&lt;code class=&quot;highlighter-rouge&quot;&gt;idea&lt;/code&gt;在右下角会弹出重新导入依赖模块的提示，我们可以进行点击导入，也可以点击提示中的”auto import”,这样在下次&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;变化时，将自动触发&lt;code class=&quot;highlighter-rouge&quot;&gt;maven&lt;/code&gt;的重新导入命令.&lt;/p&gt;

&lt;p&gt;如果你的&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;最没有导入成功，那么我们需要启动控制台，并将目录切换至&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;文件所在的目录，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;maven compile&lt;/code&gt;以使&lt;code class=&quot;highlighter-rouge&quot;&gt;maven&lt;/code&gt;来完成依赖包的导入工作&lt;a href=&quot;https://spring.io/guides/gs/maven/&quot;&gt;https://spring.io/guides/gs/maven/&lt;/a&gt;。然后再按下图进行依赖的添加。
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/31.png&quot; alt=&quot;new database springmvc&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档: &lt;a href=&quot;https://spring.io/guides/gs/accessing-data-jpa/&quot;&gt;https://spring.io/guides/gs/accessing-data-jpa/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;加入mysql模块&quot;&gt;加入mysql模块&lt;/h1&gt;
&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;的步骤相似，我们用同样的方法，加入&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;模块，并重新导入该模块。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--jpa 模块：关系型数据库--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--数据库类型：mysql--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重新导入依赖模块略。&lt;/p&gt;

&lt;h1 id=&quot;测试&quot;&gt;测试&lt;/h1&gt;
&lt;p&gt;我们点击右上角的运行按钮：
&lt;img src=&quot;/SpringMVC/assets/image/chapter1/9.png&quot; alt=&quot;run project&quot; /&gt;并查看&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;下侧的控制台，将得到如下的错误提示。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;***************************
APPLICATION FAILED TO START
***************************

Description:

Cannot determine embedded database driver class for database type NONE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;模块给我们的一个提示，它在说，虽然我已经启动了，但是你没有告诉我要连接的数据库类型是什么。当然了，除了要告诉它要连接的数据库类型(mysql)以外，我们还需要告诉它要连接的数据名称是什么，对应的用户名和密码又都是什么。&lt;/p&gt;

&lt;h2 id=&quot;配置jpa&quot;&gt;配置JPA&lt;/h2&gt;
&lt;p&gt;打开，&lt;code class=&quot;highlighter-rouge&quot;&gt;/src/main/resources/application.properties&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;配置以下信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在项目初始化时，重新创建数据表
spring.jpa.hibernate.ddl-auto=create
# 指定连接的类型为mysql 连接的地址为：localhost 端口为3306 ，数据为springmvc
spring.datasource.url=jdbc:mysql://localhost:3306/springmvc
# 用户名为root
spring.datasource.username=root
# 密码为空
spring.datasource.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/8.png&quot; alt=&quot;new database springmvc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，我们再次启动项目，在&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;服务启动的前提下，将得到启动成功的提示:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2017-04-05 15:16:17.776  INFO 4627 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2017-04-05 15:16:17.782  INFO 4627 --- [           main] com.mengyunzhi.SpringMvcApplication      : Started SpringMvcApplication in 6.929 seconds (JVM running for 7.965)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;https://spring.io/guides/gs/accessing-data-mysql/&quot;&gt;https://spring.io/guides/gs/accessing-data-mysql/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">如果在项目刚刚生成时，你查看过生成项目的目录信息，不难发现我们在前面选择过一个叫做web的Spring核心模块，被写入了根目录下的pom.xml中。</summary></entry></feed>